use std::fs::{self, File};
use std::io::{self, Read, Write};
use std::path::{Path, PathBuf};
use std::time::UNIX_EPOCH;

use flate2::read::GzDecoder;
use flate2::{Compression, GzBuilder};

pub const MIN_LEVEL: u32 = 0;
pub const MAX_LEVEL: u32 = 9;

/// 限制压缩级别在 0~9 之间。
pub fn sanitize_level(level: u32) -> u32 {
    level.clamp(MIN_LEVEL, MAX_LEVEL)
}

/// 将指定文件压缩为 gzip 文件。
pub fn compress_path(input: &Path, output: &Path, level: u32) -> io::Result<()> {
    let level = sanitize_level(level);
    let mut in_file = File::open(input)?;

    let meta = in_file.metadata().ok();
    let mtime = meta
        .and_then(|m| m.modified().ok())
        .and_then(|t| t.duration_since(UNIX_EPOCH).ok())
        .map(|d| d.as_secs() as u32)
        .unwrap_or(0);

    let out_file = File::create(output)?;

    let filename_in_header = input
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("")
        .to_string();

    let mut encoder = GzBuilder::new()
        .mtime(mtime)
        .filename(filename_in_header)
        .write(out_file, Compression::new(level));

    io::copy(&mut in_file, &mut encoder)?;
    let _ = encoder.finish()?;
    Ok(())
}

/// 将任意读取器的内容压缩到指定文件。
pub fn compress_reader_to_path<R: Read>(reader: R, output: &Path, level: u32) -> io::Result<()> {
    let file = File::create(output)?;
    let _ = compress_reader_to_writer(reader, file, level)?;
    Ok(())
}

/// 将任意读取器的内容压缩到任意写入器。
pub fn compress_reader_to_writer<R: Read, W: Write>(
    mut reader: R,
    writer: W,
    level: u32,
) -> io::Result<W> {
    let level = sanitize_level(level);
    let mut encoder = GzBuilder::new().write(writer, Compression::new(level));
    io::copy(&mut reader, &mut encoder)?;
    encoder.finish()
}

/// 将 gzip 文件解压到指定文件。
pub fn decompress_path(input: &Path, output: &Path) -> io::Result<()> {
    let file = File::open(input)?;
    decompress_reader_to_path(file, output)
}

/// 将任意 gzip 流解压到指定文件。
pub fn decompress_reader_to_path<R: Read>(reader: R, output: &Path) -> io::Result<()> {
    let file = File::create(output)?;
    decompress_reader_to_writer(reader, file)
}

/// 将任意 gzip 流解压到任意写入器。
pub fn decompress_reader_to_writer<R: Read, W: Write>(reader: R, mut writer: W) -> io::Result<()> {
    let mut decoder = GzDecoder::new(reader);
    io::copy(&mut decoder, &mut writer)?;
    writer.flush()
}

/// 生成压缩输出文件的默认路径：`<input>.gz`。
pub fn default_output_for_compress(input: &Path) -> PathBuf {
    let mut p = input.to_path_buf();
    let new_name = match input.file_name().and_then(|n| n.to_str()) {
        Some(s) => format!("{}.gz", s),
        None => format!("{}.gz", input.display()),
    };
    p.set_file_name(new_name);
    p
}

/// 生成解压输出文件的默认路径：移除 `.gz` 或追加 `.out`。
pub fn default_output_for_decompress(input: &Path) -> PathBuf {
    let mut p = input.to_path_buf();
    let new_name = match input.file_name().and_then(|n| n.to_str()) {
        Some(s) => s
            .strip_suffix(".gz")
            .map(|x| x.to_string())
            .unwrap_or_else(|| format!("{}.out", s)),
        None => format!("{}.out", input.display()),
    };
    p.set_file_name(new_name);
    p
}

/// 确保输出路径可写；若父目录不存在则创建。
pub fn ensure_writable(output: &Path, force: bool) -> io::Result<()> {
    if output.exists() && !force {
        return Err(io::Error::new(
            io::ErrorKind::AlreadyExists,
            format!("输出文件已存在: {} (使用 -f 覆盖)", output.display()),
        ));
    }
    if let Some(parent) = output.parent() {
        if !parent.as_os_str().is_empty() {
            fs::create_dir_all(parent)?;
        }
    }
    Ok(())
}

/// 判断两个路径是否完全相同。
pub fn same_path(a: &Path, b: &Path) -> bool {
    a == b
}
